# 专题研究报告：基于 Eternal AI 的去中心化多 Agent 协同网络研究与实现

**小组成员：** [请在此处填写组员姓名]
**指导教师：** [请在此处填写教师姓名]
**日期：** 2025年12月11日

---

## 1. 选题背景与意义

### 1.1 选题方向
*   **方向：** 区块链 + Agent
*   **依据：** 本报告旨在响应《2025课程考核说明》中关于“区块链与人工智能结合”的建议选题方向，深入探索两项前沿技术的交叉领域。

### 1.2 研究背景
*   **AI Agent 的演进：** 人工智能正从单一功能的对话模型，向具备自主规划、记忆、工具使用及执行复杂任务能力的智能体快速演进。这些 Agent 有望成为下一代互联网的核心交互入口和自动化工具。
*   **中心化困境：** 当前，绝大多数 AI Agent 运行在由少数科技巨头控制的中心化服务器上。这种模式带来了诸多固有风险：服务可能因商业决策而中断或调整；用户数据隐私和所有权缺乏保障；模型和算法的不透明性导致信任缺失；以及平台审查可能限制 Agent 的应用范围。
*   **Eternal AI 方案：** 为应对上述挑战，Eternal AI 等开源项目提出了“完全链上代理”的前瞻性概念。其核心思想是利用区块链的去中心化、不可篡改和透明性作为 AI Agent 的基础设施，从而保障 Agent 的永续运行、逻辑透明和资产主权，构建一个无需信任、抗审查的 AI 生态系统。

### 1.3 研究意义
*   **学术价值：** 本研究深入探索了将区块链作为 AI Agent 核心基础设施的技术可行性。重点分析了将 Agent 资产化为 NFT 的 `AI721` 标准，以及链上智能合约驱动链下大模型推理的混合架构机制。这为去中心化 AI 的理论研究提供了宝贵的实践案例。
*   **应用价值：** 本报告不仅分析了现有系统，还针对当前去中心化 AI 生态中 Agent 普遍相互孤立、“各自为战”的现状，提出了一个创新的“链上多 Agent 协同网络 ”改进方案。该方案旨在解决单个 Agent 在处理复杂、多阶段任务时的能力瓶颈，通过构建链上协作与激励机制，显著提升去中心化 AI 系统的整体能力和应用价值。

---

## 2. Eternal AI 架构深度解析：从协议到应用
### 2.1 顶层设计与核心思想

#### 2.1.1 项目愿景与定位
Eternal AI 的核心愿景是构建一个去中心化、抗审查、由经济激励驱动的永续 AI Agent 网络。它旨在打破当前 AI 由中心化实体垄断的格局，将 AI Agent 的定义权、所有权和控制权交还给用户和开发者。在这个网络中，Agent 不再是依附于特定服务器的临时服务，而是成为一种可拥有、可交易、可组合的链上数字资产，能够永久存在并自主运行。

#### 2.1.2 核心架构：链上信任锚与链下计算层
为实现这一愿景，Eternal AI 采用了创新的“链上信任锚 + 链下计算层”混合架构。

*   **核心思想：** 该架构巧妙地解决了区块链的“不可能三角”问题。它将系统的不同功能进行解耦：
    *   **链上**：利用智能合约作为网络的“信任锚”或“调度结算总线”，负责处理状态敏感、需要高度共识的关键逻辑，如 Agent 的注册与所有权、任务的发布与分配、计算结果的验证以及经济激励的结算。
    *   **链下**：将计算密集型任务交由一个去中心化的物理基础设施网络执行。这些链下节点通过监听链上事件来获取任务，并在本地完成计算后将结果提交回链上。

这种设计既利用了区块链的透明与可信，又释放了链下硬件的强大计算能力，实现了两全其美。

*   **核心架构图**
    ![核心架构图](./puml/2_1_2_core_architecture.puml)

### 2.2 协议层：AI Kernel - 网络的链上灵魂

AI Kernel 是 Eternal AI 的核心，由一组部署在区块链上的智能合约构成，是整个网络的操作系统和信任基石。

#### 2.2.1 `AI721` 标准：Agent 的数字身份与资产化
`AI721` 是一个遵循 ERC-721 规范的扩展协议，它将 AI Agent 封装为独一无二的 NFT。这使得 Agent 不仅是代码，更是一种可拥有、可交易的数字资产。

*   **功能深度解析：** `AI721` NFT 是 Agent 的链上“数字护照”，其元数据包含了定义一个 Agent 的所有核心要素。
*   **源码分析：** 在 `AI721.sol` 合约中，`AgentConfig` 结构体是 Agent 的基因蓝图。
    ```solidity
    // file: eternal-ai-master/decentralized-agents/contracts/standards/AI721.sol

    struct AgentConfig {
        address owner;          // Agent NFT 的所有者
        string systemPrompt;    // 系统提示词，定义 Agent 的角色、行为和目标
        string modelId;         // Agent 使用的 LLM 模型标识
        address[] tools;        // Agent 可调用的外部工具合约地址列表
        uint256 usageFee;       // 每次调用 Agent 所需支付的费用
    }
    ```
    通过 `mint` 函数，任何人都可以根据 `AgentConfig` 创建一个新的 Agent NFT，从而在链上注册一个全新的、具有独特能力的 AI Agent。

*   **AgentConfig 结构体可视化**
    ![AgentConfig 结构体](./puml/2_2_1_agent_config_class.puml)

#### 2.2.2 `WorkerHub` & `PromptScheduler`：去中心化 AI 任务市场
这两个合约共同构成了一个去中心化的任务发布与算力撮合市场。

*   **经济模型闭环：**
    1.  **注册/质押：** 算力提供者调用 `WorkerHub.sol` 的 `registerMiner` 函数，通过质押一定数量的代币加入网络，成为可信的计算节点。
    2.  **任务发布：** 用户通过调用 `PromptScheduler.sol` 的 `infer` 函数，提交一个推理请求，并支付相应的费用。
    3.  **任务分配：** `PromptScheduler` 的 `_assignMiners` 内部逻辑会根据矿工的在线状态、质押量、信誉等因素，选择一个或多个矿工来执行任务。
    4.  **结果提交与验证：** 矿工完成计算后，调用 `WorkerHub.sol` 的 `submitSolution` 函数将结果和证明提交上链。
    5.  **激励结算：** 合约验证结果后，会自动将用户支付的费用分配给成功完成任务的矿工，形成一个完整的经济激励闭环。

    ![经济模型闭环活动图](./puml/2_2_2_economic_model_activity.puml)

*   **源码分析：** `infer` 请求是驱动整个系统的起点。
    ```solidity
    // file: eternal-ai-master/ai-kernel/contracts/PromptScheduler.sol

    function infer external payable {
        // ... 验证 agentId 和支付的费用 ...

        address[] memory selectedMiners = _assignMiners; // 分配矿工

        // ... 创建任务并触发 TaskAssigned 事件 ...
        emit TaskAssigned;
    }
    ```

### 2.3 执行层：链下基础设施与服务

#### 2.3.1 `Decentralized Compute`：网络的算力基石
矿工节点是网络的物理算力基础，它们是运行在 Go 语言上的链下程序。

*   **工作流详解：**
    1.  **启动与监听：** 矿工程序启动后，会连接到区块链节点，并持续监听 `WorkerHub` 合约触发的 `TaskAssigned` 事件。
    2.  **任务获取：** 一旦监听到分配给自己的任务，矿工会从事件日志中解析出 `agentId` 和 `prompt`。
    3.  **执行推理：** 矿工根据 `agentId` 从链上获取 Agent 的配置，然后调用本地或云端部署的 LLM 模型执行推理计算。
    4.  **提交结果：** 计算完成后，矿工将结果打包，并作为交易调用 `WorkerHub` 的 `submitSolution` 函数，将结果写回链上。

    `miner.go` 中的 `ExecuteTasks` 函数是这一流程的核心实现。

    ![矿工工作流活动图](./puml/2_3_1_miner_workflow_activity.puml)
    
    ```go
    // file: eternal-ai-master/decentralized-compute/miner/internal/usecase/miner.go

    func  ExecuteTasks error {
        // ... 监听区块链事件 ...
        for event := range events {
            // ... 解析任务 ...
            go m.processTask // 并发处理任务
        }
        return nil
    }
    ```

#### 2.3.2 `Decentralized Storage`：Agent 的永续记忆
对于大型 AI 模型文件、Agent 的长期记忆或知识库等海量数据，直接存储在区块链上是不现实的。因此，项目规划集成 Arweave、Filecoin 等去中心化存储方案，作为 Agent 的“永续记忆体”，确保数据的持久化、可用性和抗审查性。

### 2.4 应用层：生态入口与开发者赋能

#### 2.4.1 `Agent-as-a-Service`：面向用户的统一网关
`agent-orchestration` 模块是一个关键的中间件，它作为后端服务，为前端应用屏蔽了底层区块链交互的复杂性。开发者无需直接与智能合约打交道，只需通过调用该服务提供的标准 RESTful API，即可轻松发起 Agent 推理请求。

#### 2.4.2 `EternalAI.js`：面向开发者的 SDK
为进一步降低开发门槛，项目提供了 `EternalAI.js` 库。这个 JavaScript SDK 封装了与 `Agent-as-a-Service` 的所有通信细节，使得第三方开发者可以像调用普通 npm 包一样，在自己的网站或 DApp 中轻松集成、发现和使用 Eternal AI 网络中的海量 Agent。

### 2.5 实例贯通：一次完整的“深度研究”任务生命周期

为了将上述所有组件串联起来，我们以一次具体的“深度研究”任务为例，展示其端到端的生命周期。

*   **任务生命周期**
    ![任务生命周期](./puml/2_5_task_lifecycle.puml)

---

## 3. 系统设计与改进方案：链上多 Agent 协同网络 
**

### 3.1 现有系统局限性深度分析

经过对 Eternal AI 架构的深入剖析，我们认为其在单体 Agent 的去中心化运行方面取得了显著进展，但在构建一个网络化、智能化的 Agent 生态方面，仍存在以下三个层面的局限性：

*   **3.1.1 Agent 间的“孤岛效应”与通信缺失：**
    `AI721` 标准成功地实现了 Agent 的资产化，但其设计本质上是原子化的，仅定义了 Agent 的个体属性，而缺乏描述 Agent 之间关系或通信渠道的原生协议。这导致了一个碎片化的生态系统，Agent 无法在链上相互发现、建立信任、委托任务或共享知识。这种“孤岛效应”极大地限制了网络集体智能的涌现。

*   **3.1.2 复杂任务处理的“能力天花板”：**
    单个 Agent 即使拥有多种工具，其单线程的“规划-执行-反馈”循环在面对复杂工作流时也显得力不从心。例如，一份高质量的市场研究报告需要数据搜集、数据清洗与分析、图表生成和文字撰写四个步骤，这天然需要不同角色的专家协作。单个 Agent 难以同时精通所有领域，从而形成了一个难以突破的能力上限。

*   **3.1.3 经济模型的激励单一性：**
    现有的经济模型仅支持“用户-Agent”的单点对单点交易，即用户付费调用单个 Agent。这种模式无法为 Agent 之间的协作行为提供经济激励。如果一个 Agent将任务分包给另一个 Agent，现有的协议无法保证执行者能获得公平的收益。这从经济学角度抑制了 Agent 之间自发形成复杂协作生态的可能性。

### 3.2 改进目标与核心设计原则

为突破上述局限性，我们的改进目标是在 `AI721` 标准之上，设计一个全新的、可组合的**链上协作协议层**，使 Agent 能够从“孤立个体”演进为“网络化组织”。为实现此目标，我们遵循以下四大核心设计原则：

1.  **最小化链上开销 :** 协作逻辑的核心状态和最终验证必须在链上完成以保证信任，但重量级数据应在链下传递，以最大程度地降低 Gas 成本。
2.  **可组合性与可扩展性 :** 协议应足够灵活，不仅要支持基础的委托模式，还要能为未来更复杂的协作模式提供可扩展的基础。
3.  **向后兼容性 :** 该协同协议应作为 `AI721` 的一个可选的、附加的“能力层”，不影响现有单体 Agent 的注册和独立运行。
4.  **激励相容性 :** 必须设计公平、透明且自动化的激励分配机制，确保所有参与协作的 Agent 所有者都能获得与其贡献相匹配的收益，从而驱动生态正向发展。

### 3.3 详细改进设计：`SquadManager` 协议

我们设计的核心是一个名为 `SquadManager.sol` 的智能合约，它作为链上协作的中枢，并与一个增强的链下服务协同工作。

#### 3.3.1 合约层设计 

*   **Squad 的链上注册与管理：**
    合约将定义一个 `Squad` 结构体来记录协作关系，并提供一系列管理函数。
    ```solidity
    // 伪代码
    struct Squad {
        address owner; // Squad 的所有者，通常是 Leader Agent 的所有者
        uint256 leaderAgentId; // 领导者 Agent 的 NFT ID
        mapping isMember; // 成员 Agent ID 集合
        mapping shares; // 成员收益分配比例
    }

    function createSquad external;
    function addMember external;
    function removeMember external;
    ```
    ![Squad 结构体](./puml/3_3_1_squad_struct_class.puml)
    
    所有管理函数都将进行严格的权限控制，只有 Squad 的所有者才能修改其成员和收益分配。

*   **任务委托与事件驱动流 ：**
    `delegateTask` 函数是触发协作的核心。它不在链上直接执行任务，而是通过发射一个标准化的 `SubTaskAssigned` 事件，将任务安全地广播出去。
    ```solidity
    // 伪代码
    event SubTaskAssigned;

    function delegateTask external;
    ```

*   **自动化利益分配模型：**
    为实现无需信任的利益分配，当用户向一个 Squad Leader Agent 支付费用时，资金不会直接进入其所有者账户，而是进入一个与该 Squad 绑定的、类似 OpenZeppelin 的 `PaymentSplitter` 分账合约。任务完成后，任何参与者都可以触发该合约，将资金按照预设的 `shares` 比例自动分配给所有成员的所有者。
    
    ![自动化利益分配活动图](./puml/3_3_1_payment_splitter_activity.puml)

#### 3.3.2 应用层增强 

*   **协同编排器 ：**
    这是一个增强版的链下服务，其核心职责是监听和响应 `SquadManager` 合约的事件。
    1.  **事件监听：** 持续监听 `SubTaskAssigned` 事件。
    2.  **上下文管理：** 当监听到事件后，根据 `contextPointer` 从去中心化存储中拉取详细的任务上下文数据。
    3.  **任务调度：** 调用目标 Worker Agent 的执行接口，并将上下文数据作为输入。待 Worker Agent 完成后，将结果安全地传递回 Leader Agent。

*   **上下文共享协议 ：**
    我们提出一个低成本的链下上下文共享方案。在调用 `delegateTask` 时，`contextPointer` 参数传递的不是数据本身，而是一个指向存储在 IPFS 上的上下文数据的指针。这实现了在链上交互保持轻量的同时，又能传递丰富的任务信息。

#### 3.3.3 协作模式探讨

基于 `SquadManager` 协议的灵活性，可以支持多种高级协作模式：

*   **流水线模式 :** 适用于多阶段处理任务。一个 Squad 可以被配置成 Agent A 的输出自动作为 Agent B 的输入，形成一个处理流水线，极大地提升了自动化处理的效率。
*   **议会模式 :** 适用于需要多角度分析或验证的任务。Leader Agent 可以将同一个任务分发给多个具有不同专长的 Worker Agent，然后对返回的多个结果进行汇总、比较或投票，以得出最可靠的结论。

---

## 4. 改进方案的实验设计
**

### 4.1 实验目标与核心假设

#### 4.1.1 实验目标
为科学地评估第三部分提出的“链上多 Agent 协同网络”方案，我们设计了以下实验目标：
*   **主要目标：** 从理论上验证“链上多 Agent 协同网络 ”机制在处理复杂、多阶段任务时，相较于传统的单体 Agent 架构，是否具有显著的优越性。
*   **次要目标：** 定量评估该协同机制在实现优越性的同时，可能引入的额外链上开销和系统端到端延迟，以分析其可行性。

#### 4.1.2 核心假设 
本次实验基于以下核心假设：
*   **H1 :** 一个采用“规划者-执行者”模型的 Agent Squad，能够成功完成单个 Agent 因能力或角色限制而无法独立完成、或完成质量较低的复杂任务。

### 4.2 实验变量与对照组设计

为确保实验的严谨性，我们采用对照实验法。

*   **关键变量:**
    *   **自变量：** Agent 的工作模式，即“协同网络模式”与“单体 Agent 模式”。
    *   **因变量：** 我们将观测并记录三个关键指标：任务完成质量、任务完成总时间、以及链上交互产生的总 Gas 成本。

*   **实验组与对照组:**
    *   **实验组 :** 构建一个 Agent Squad，其中包含一个负责任务规划与拆解的 Planner Agent，以及两个负责执行具体子任务的 Worker Agent。
    *   **对照组 :** 选择一个能力最强的单体 Agent，并为其配置与实验组中 Worker Agent 相同的工具集，以确保其具备完成任务所需的所有基础能力。

### 4.3 模拟场景与任务设计

#### 4.3.1 模拟测试环境
实验将在一个理论的、可控的区块链模拟环境中进行，例如使用 Hardhat 的 Mainnet Fork 功能。这可以确保我们对 Gas 成本的估算接近真实网络环境，同时排除网络拥堵等外部因素的干扰。

#### 4.3.2 标准化测试任务 
为了使实验结果具有可比性，我们设计一个标准化的、可量化的复杂任务。该任务应具备可拆解性，以充分考验协同网络的能力。
*   **示例任务：** “请调研以太坊 EIP-4844 的核心机制、社区对其的普遍反馈、以及其主网上线后对二层网络交易 Gas 成本的实际影响，并最终生成一份包含这三方面内容的综合性总结报告。”

### 4.4 实验流程设计

#### 4.4.1 对照组测试流程
1.  向对照组的单体 Agent 提交上述标准化测试任务。
2.  记录其从接收任务到输出最终报告的完整时间。
3.  对最终生成的报告进行质量评估。

#### 4.4.2 实验组测试流程
1.  向实验组的 Planner Agent 提交相同的标准化测试任务。
2.  记录其从接收任务到输出最终报告的完整时间，并记录流程中所有链上交互的总 Gas 成本。
3.  对最终生成的报告进行质量评估。
4.  **实验流程**
    ![实验流程](./puml/4_4_2_experiment_flow.puml)
---

## 5. 总结与展望
*   **总结：** 本报告深入研究了 Eternal AI 开源项目，系统性地剖析了其从顶层设计到协议层、执行层和应用层的完整技术架构。在此基础上，我们识别出现有系统在多 Agent 协作方面的局限性，并设计了一套名为“链上多 Agent 协同网络”的创新改进方案。该方案通过引入新的智能合约和应用层逻辑，有望显著增强去中心化 AI 网络的复杂任务处理能力。
*   **展望：** 我们相信，基于区块链的多 Agent 协同技术拥有广阔的应用前景。未来，该技术可进一步应用于构建完全自主的去中心化自治组织，实现组织任务的自动化管理和执行；在去中心化金融领域，可以构建由多个策略 Agent 组成的智能投顾“基金”；在去中心化科学领域，可以自动化地协调数据分析、模型训练和论文撰写等科研流程。这项研究为通向一个更加智能、自主和去中心化的未来奠定了坚实的基础。
