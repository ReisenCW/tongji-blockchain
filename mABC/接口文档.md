# 接口文档

## 1. 区块链底层组 (Blockchain Core)

### 成员 1: 区块链核心开发 (数据层)

**核心职责**: 定义数据结构，维护链的完整性。

| 阶段         | 接口名                                     | 输入                                 | 输出                                 | 处理逻辑                                                             |
| :----------- | :----------------------------------------- | :----------------------------------- | :----------------------------------- | :------------------------------------------------------------------- |
| **数据定义** | `Transaction`, `Block`, `Account` (类定义) | 无                                   | `Transaction`, `Block`, `Account` 类 | 定义 Pydantic 模型或 Python 类。                                     |
| **哈希计算** | `calculate_hash`, `get_merkle_root`        | 任意字符串/字节流                    | 哈希值 (String)                      | 实现 SHA256 哈希算法；实现 Merkle Tree 根哈希计算。                  |
| **链维护**   | `Blockchain.add_block`                     | `Block` 对象 (来自成员 2 的挖矿结果) | 更新后的区块链列表                   | 验证区块哈希链接 (`prev_hash`)；将合法区块追加到 `self.chain` 列表。 |
| **公钥管理** | `PublicKeyRegistry.get_public_key`         | 地址 (String)                        | 公钥 (String)                        | 根据账户地址查找对应的公钥，供成员 2 进行签名验证使用。              |
| **地址生成** | `generate_address`                         | 公钥 (bytes)                         | 地址 (String)                        | 实现从公钥生成账户地址的算法（如 SHA256 + 截取）。                   |

### 成员 2: 区块链核心开发 (执行层)

**核心职责**: 交易执行与状态更新。

| 阶段           | 接口名                             | 输入               | 输出              | 处理逻辑                                                                                                                                   |
| :------------- | :--------------------------------- | :----------------- | :---------------- | :----------------------------------------------------------------------------------------------------------------------------------------- |
| **交易池管理** | `Blockchain.add_transaction`       | `Transaction` 对象 | bool              | 验证交易签名；检查 Nonce 防止重放；检查 Gas 限制；检查发送者余额；加入 `pending_transactions`。                                            |
| **挖矿/出块**  | `Blockchain.mine_block`            | 无显式参数         | `Optional[Block]` | 从池中取出交易；为每笔交易扣除 Gas 费用；调用 `state_processor.apply_transaction()` 执行交易；使用成功交易创建新区块；计算并设置区块哈希。 |
| **状态更新**   | `StateProcessor.apply_transaction` | `Transaction` 对象 | bool              | 解析交易类型；根据交易类型调用对应处理函数（如 `_apply_propose_root_cause`, `_apply_vote` 等）更新全局状态。                               |

#### 1. 交易池管理接口

**接口名称**: `Blockchain.add_transaction`

**功能描述**: 将交易添加到待处理交易池中，等待被打包进区块。

**输入参数**:

- `tx` (Transaction): 交易对象，包含交易类型、发送者地址、nonce、gas 价格、gas 限制、数据和签名等信息

**返回值**:

- `bool`: 交易是否成功添加到交易池

**处理逻辑**:

1. 验证交易签名的有效性，确保交易确实由发送者发起
   - 使用成员 1 提供的 `PublicKeyRegistry.get_public_key()` 方法获取发送者公钥
   - 使用 ECDSA 验证交易签名
2. 检查交易的 nonce 值是否与发送者账户的 nonce 匹配，防止重放攻击
3. 验证交易的 gas 限制是否满足最低要求（默认最小值为 21000）
4. 检查发送者的账户余额是否足够支付交易所需的 gas 费用（gas_price \* gas_limit）
5. 若以上验证均通过，则将交易添加到待处理交易池(`pending_transactions`)中

#### 2. 挖矿/出块接口

**接口名称**: `Blockchain.mine_block`

**功能描述**: 从交易池中取出待处理交易，执行这些交易并生成新的区块。

**输入参数**: 无显式参数，内部使用交易池状态

**返回值**:

- `Optional[Block]`: 成功挖矿时返回新生成的区块对象，若没有待处理交易则返回 None

**处理逻辑**:

1. 检查是否存在待处理交易，若无则直接返回
2. 从交易池中复制所有待处理交易，并清空交易池
3. 为每个交易扣除相应的 gas 费用（gas_price \* gas_limit）
4. 调用`state_processor.apply_transaction()`执行每笔交易
5. 对于成功执行的交易，增加发送者账户的 nonce 值
6. 对于执行失败的交易，退还已扣除的 gas 费用
7. 使用成功执行的交易创建新区块，包含正确的区块头信息（索引、时间戳、前一区块哈希、Merkle 根）
8. 计算并设置新区块的哈希值
9. 将新区块添加到区块链中

#### 3. 状态更新接口

**接口名称**: `StateProcessor.apply_transaction`

**功能描述**: 根据交易类型执行相应的状态更新操作。

**输入参数**:

- `tx` (Transaction): 需要被执行的交易对象

**返回值**:

- `bool`: 交易是否成功应用

**处理逻辑**:

1. 根据交易对象中的`tx_type`字段确定交易类型
2. 若为根因提案交易(`propose_root_cause`)，调用`_apply_propose_root_cause`方法创建新的根因提案
3. 若为投票交易(`vote`)，调用`_apply_vote`方法处理投票，委托给成员 4 的治理合约执行
4. 若为转账交易(`transfer`)，调用`_apply_transfer`方法执行转账，委托给成员 3 的 Token 合约执行
5. 若为质押交易(`stake`)，调用`_apply_stake`方法处理质押，委托给成员 3 的 Token 合约执行
6. 若为惩罚交易(`slash`)，调用`_apply_slash`方法处理惩罚，委托给成员 3 的 Token 合约执行
7. 根据交易类型调用相应的方法更新世界状态(`WorldState`)
8. 将更新后的状态持久化存储到数据库中

---

## 2. 智能合约组 (Smart Contracts)

### 成员 3: 智能合约开发 (流程控制)

**核心职责**: 运维 SOP 状态机逻辑。

#### 1. 核心交易方法（Agent 通过交易调用，由 VM 分发）

| 方法名                   | 对应交易类型（tx_type）    | 参数                                                                        | 返回值                                               | 调用条件（当前状态） | 功能描述                                     | 发射事件            |
| ------------------------ | -------------------------- | --------------------------------------------------------------------------- | ---------------------------------------------------- | -------------------- | -------------------------------------------- | ------------------- |
| `submit_data_collection` | `"submit_data_collection"` | `agent_id: str`<br>`data_summary: str`<br>`raw_data: Optional[Dict] = None` | `dict`（包含 `new_state`, `message`）                | **Init**             | 提交故障数据采集结果，推进至数据采集完成阶段 | `DataCollected`     |
| `propose_root_cause`     | `"propose_root_cause"`     | `agent_id: str`<br>`content: str`                                           | `dict`（包含 `proposal_id`, `new_state`, `message`） | **Data_Collected**   | 提出根因分析提案，推进至根因提案阶段         | `RootCauseProposed` |

#### 2. 内部协作方法（仅供治理合约调用）

| 方法名                       | 参数                                 | 返回值             | 调用条件（当前状态）    | 功能描述                                                                                   | 发射事件                                                                                                    |
| ---------------------------- | ------------------------------------ | ------------------ | ----------------------- | ------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------- |
| `advance_to_consensus_phase` | `proposal_id: str`<br>`passed: bool` | 无（直接更新状态） | **Root_Cause_Proposed** | 根据成员 4 的共识结果推进状态<br>通过 → Consensus → Solution<br>否决 → 回退 Data_Collected | `ConsensusReached`（passed=True/False）<br>`SolutionPhaseEntered`（通过时）<br>`ProposalRejected`（否决时） |

#### 3. 查询方法（供前端、API、监控使用，只读）

| 方法名                        | 参数                 | 返回值                                    | 描述                                     |
| ----------------------------- | -------------------- | ----------------------------------------- | ---------------------------------------- |
| `get_current_state()`         | 无                   | `str`（如 "Data_Collected"）              | 获取当前 SOP 所处阶段                    |
| `get_events(limit: int = 50)` | `limit: int`（可选） | `List[Dict]`（最近的事件列表，倒序）      | 获取事件日志，用于审计和实时展示         |
| `get_current_proposal()`      | 无                   | `Optional[Dict]`（当前提案详情，或 None） | 获取当前活跃提案（proposer、content 等） |
| `get_incident_data()`         | 无                   | `Dict`（数据采集阶段提交的信息）          | 获取本次故障的数据采集摘要和原始数据     |

#### 4. 事件类型（Event）列表（供前端订阅/展示，监听奖惩触发）

| 事件名                 | 携带字段示例                         | 触发时机                                 |
| ---------------------- | ------------------------------------ | ---------------------------------------- |
| `DataCollected`        | `agent_id`, `summary`                | 数据采集提交成功                         |
| `RootCauseProposed`    | `proposal_id`, `proposer`, `content` | 根因提案提交成功                         |
| `ConsensusReached`     | `proposal_id`, `passed: bool`        | 成员 4 调用 advance 后（无论通过或否决） |
| `SolutionPhaseEntered` | `proposal_id`, `root_cause`          | 提案通过，进入解决方案阶段               |
| `ProposalRejected`     | `proposal_id`, `proposer`            | 提案被否决                               |

#### 5. 测试辅助方法（仅单元测试使用）

| 方法名                | 描述                                  |
| --------------------- | ------------------------------------- |
| `reset_for_testing()` | 重置所有状态为 Init（仅测试环境使用） |

### 成员 4: 智能合约开发 (经济模型)

**核心职责**: Token 管理与共识计算。

| 阶段           | 接口名                                                                 | 输入                                      | 输出                           | 处理逻辑                                                   |
| :------------- | :--------------------------------------------------------------------- | :---------------------------------------- | :----------------------------- | :--------------------------------------------------------- |
| **Token 管理** | `TokenContract.transfer`, `TokenContract.stake`, `TokenContract.slash` | `Transaction` (类型: `TRANSFER`, `STAKE`) | 更新后的 `balances` 字典       | 检查余额；执行转账/质押/扣除操作；更新账本。               |
| **共识投票**   | `GovernanceContract.vote`                                              | `Transaction` (类型: `VOTE`)              | 提案状态 (`Passed`/`Rejected`) | 记录投票；计算权重 (`质押量 * 信誉分`)；判断是否达到阈值。 |

---

## 3. Agent 适配组 (Agent Adapter)

### 成员 5: Agent 中间件开发

**核心职责**: 链上交互中间件，连接 Agent 决策与区块链执行。

#### 1. 核心组件概述

| 组件               | 文件路径                    | 功能描述                                         |
| ------------------ | --------------------------- | ------------------------------------------------ |
| `ChainClient`      | `mABC/core/client.py`       | 区块链客户端封装，提供统一的链上交互接口         |
| `DAOExecutor`      | `mABC/agents/base/dao_run.py` | DAO 投票执行器，替代原有的 ThreeHotCotRun        |
| Agent 钱包扩展     | `mABC/agents/base/profile.py` | 为所有 Agent 添加钱包功能（地址、公钥、私钥）    |

#### 2. ChainClient 区块链客户端接口

**类名**: `ChainClient`

**功能描述**: 封装所有区块链交互操作，为 Agent 和 DAO 执行器提供统一的链上接口。

##### 2.1 交易管理接口

| 方法名                 | 输入参数                                                                                                      | 返回值        | 功能描述                                       |
| ---------------------- | ------------------------------------------------------------------------------------------------------------- | ------------- | ---------------------------------------------- |
| `create_transaction`   | `tx_type: str`<br>`sender: str`<br>`data: Dict[str, Any]`<br>`private_key: SigningKey`<br>`gas_limit: int = 21000` | `Transaction` | 创建并签名交易，自动生成 nonce 和时间戳        |
| `sign_transaction`     | `tx: Transaction`<br>`private_key: SigningKey`                                                                | `str`         | 使用 ECDSA 对交易进行签名，返回签名的十六进制字符串 |
| `send_transaction`     | `tx: Transaction`                                                                                             | `bool`        | 将交易发送到交易池                             |
| `send_and_mine`        | `tx: Transaction`                                                                                             | `bool`        | 发送交易并立即触发出块（用于测试和 DAO 场景） |
| `get_pending_transactions` | 无                                                                                                        | `List[Transaction]` | 获取待处理交易列表                        |

**签名算法**: ECDSA (SECP256k1 曲线) + SHA256 哈希 + DER 编码

**处理逻辑**:
1. `create_transaction`: 从 world_state 获取发送者 nonce，构造交易对象，调用 `sign_transaction` 签名
2. `sign_transaction`: 排除 signature 字段后序列化交易为 JSON，使用 `calculate_hash` 计算哈希，使用 `sign_digest` 生成签名
3. `send_and_mine`: 先调用 `send_transaction` 添加到交易池，再调用 `mine_block` 触发出块

##### 2.2 区块链查询接口

| 方法名                 | 输入参数                  | 返回值                    | 功能描述                         |
| ---------------------- | ------------------------- | ------------------------- | -------------------------------- |
| `get_account`          | `address: str`            | `Optional[Account]`       | 查询账户信息                     |
| `get_balance`          | `address: str`            | `int`                     | 查询账户余额                     |
| `get_stake`            | `address: str`            | `int`                     | 查询账户质押金额                 |
| `get_block_height`     | 无                        | `int`                     | 获取当前区块链高度               |
| `get_blockchain_info`  | 无                        | `Dict[str, Any]`          | 获取区块链综合信息（高度、最新区块哈希等） |

##### 2.3 智能合约交互接口

| 方法名              | 输入参数                                                  | 返回值          | 功能描述                         |
| ------------------- | --------------------------------------------------------- | --------------- | -------------------------------- |
| `get_events`        | `contract_name: str = ""`<br>`event_name: str = ""`<br>`limit: int = 50` | `List[Dict]` | 获取智能合约事件日志             |
| `check_consensus`   | `proposal_id: str`                                        | `Dict[str, Any]` | 检查提案的共识结果（通过/否决） |

##### 2.4 区块操作接口

| 方法名         | 输入参数 | 返回值             | 功能描述               |
| -------------- | -------- | ------------------ | ---------------------- |
| `mine_block`   | 无       | `Optional[Block]`  | 触发出块，执行交易池中的交易 |

#### 3. DAOExecutor DAO 投票执行器接口

**类名**: `DAOExecutor`

**功能描述**: 管理 Agent 集体投票流程，替代原有的 ThreeHotCotRun，将 Agent 决策转换为区块链交易。

##### 3.1 初始化接口

| 参数名      | 类型         | 默认值 | 描述                                     |
| ----------- | ------------ | ------ | ---------------------------------------- |
| `blockchain` | `Blockchain` | 必填   | 区块链实例                               |
| `alpha`     | `float`      | 0.5    | 支持率阈值（50%），达到此比例视为通过    |
| `beta`      | `float`      | 0.5    | 参与率阈值（50%），达到此比例投票才有效  |

##### 3.2 核心运行接口

**方法名**: `run`

**输入参数**:
- `agents: List[Agent]` - 参与投票的 Agent 列表
- `poll_role: str` - 投票角色（如 "DataDetective"）
- `poll_problem: str` - 投票问题描述
- `poll_content: str` - 投票内容详情

**返回值**: `Dict[str, Any]` - 包含投票结果和统计信息

**返回字段**:
```python
{
    "result": bool,              # 投票是否通过
    "passed": bool,              # 同 result
    "votes": List[Dict],         # 每个 Agent 的投票详情
    "statistics": {
        "total_agents": int,     # 参与的 Agent 总数
        "for_votes": int,        # 支持票数
        "against_votes": int,    # 反对票数
        "support_rate": float,   # 支持率
        "participation_rate": float,  # 参与率
        "consensus_reached": bool     # 是否达成共识
    }
}
```

**处理逻辑**:
1. 为每个参与投票的 Agent 质押 Token（根据账户余额动态计算质押量）
2. 调用每个 Agent 的 `run()` 方法获取投票决策
3. 将每个 Agent 的投票封装为 `vote` 类型的区块链交易
4. 使用 Agent 的私钥对交易进行签名
5. 通过 `chain_client.send_and_mine()` 将交易上链
6. 统计投票结果，计算支持率和参与率
7. 根据 alpha（支持率阈值）和 beta（参与率阈值）判断是否达成共识

##### 3.3 内部辅助方法

| 方法名                              | 功能描述                               |
| ----------------------------------- | -------------------------------------- |
| `_stake_tokens`                     | 为 Agent 质押 Token，作为投票保证金    |
| `_calculate_stake_amount`           | 根据余额计算质押金额（10%-30%）        |
| `_create_and_submit_vote_transaction` | 创建投票交易并提交上链               |
| `_parse_agent_response`             | 解析 Agent 返回的投票结果              |

#### 4. Agent 钱包扩展接口

**功能描述**: 为所有 Agent 类添加区块链钱包功能，使其能够签名交易和参与链上投票。

##### 4.1 新增属性

所有 Agent 类（DataDetective, DependencyExplorer, ProbabilityOracle, FaultMapper, AlertReceiver, ProcessScheduler, SolutionEngineer）新增以下属性：

| 属性名          | 类型          | 描述                                   |
| --------------- | ------------- | -------------------------------------- |
| `wallet_address` | `str`        | 钱包地址（通过公钥哈希生成）           |
| `private_key`   | `SigningKey`  | ECDSA 私钥（SECP256k1 曲线）           |
| `public_key`    | `VerifyingKey` | ECDSA 公钥                             |

##### 4.2 初始化逻辑

在每个 Agent 的 `__init__` 方法中自动执行：
1. 生成 ECDSA 密钥对（SECP256k1 曲线）
2. 使用成员 1 的 `generate_address` 函数从公钥生成钱包地址
3. 将公钥注册到 `PublicKeyRegistry`，供签名验证使用

**代码示例**:
```python
from ecdsa import SigningKey, SECP256k1
from core.types import generate_address, PublicKeyRegistry

# 在 Agent.__init__ 中
self.private_key = SigningKey.generate(curve=SECP256k1)
self.public_key = self.private_key.get_verifying_key()
self.wallet_address = generate_address(self.public_key.to_string())
PublicKeyRegistry.register_public_key(
    self.wallet_address, 
    self.public_key.to_string().hex()
)
```

#### 5. 与其他模块的接口协作

##### 5.1 与成员 2（执行层）的接口

| 调用方向           | 接口名                      | 说明                               |
| ------------------ | --------------------------- | ---------------------------------- |
| ChainClient → VM   | `Blockchain.add_transaction` | 提交交易到交易池                   |
| ChainClient → VM   | `Blockchain.mine_block`     | 触发出块，执行交易                 |
| VM → ChainClient   | 交易签名验证                | VM 使用 PublicKeyRegistry 验证签名 |

##### 5.2 与成员 3（流程控制合约）的接口

| 调用方向              | 接口名                    | 说明                         |
| --------------------- | ------------------------- | ---------------------------- |
| DAOExecutor → Contract | `OpsContract.propose_root_cause` | 提交根因提案到 SOP 状态机 |
| ChainClient → Contract | `OpsContract.get_events`  | 查询事件日志                 |

##### 5.3 与成员 4（经济模型合约）的接口

| 调用方向              | 接口名                       | 说明                         |
| --------------------- | ---------------------------- | ---------------------------- |
| DAOExecutor → Contract | `TokenContract.stake`       | Agent 投票前质押 Token       |
| DAOExecutor → Contract | `GovernanceContract.vote`   | 记录投票并计算共识           |
| ChainClient → Contract | `GovernanceContract.check_consensus` | 查询提案共识结果      |

#### 6. 使用示例

##### 6.1 使用 ChainClient 查询账户余额

```python
from core.vm import Blockchain
from core.client import ChainClient

blockchain = Blockchain()
client = ChainClient(blockchain)

# 查询余额
balance = client.get_balance("account_address_here")
print(f"余额: {balance} Token")
```

##### 6.2 使用 DAOExecutor 执行投票

```python
from core.vm import Blockchain
from agents.base.dao_run import DAOExecutor
from agents.base.profile import DataDetective, DependencyExplorer, FaultMapper

# 初始化
blockchain = Blockchain()
dao_executor = DAOExecutor(blockchain, alpha=0.5, beta=0.5)

# 创建 Agent
agents = [DataDetective(), DependencyExplorer(), FaultMapper()]

# 初始化账户余额
from core.state import world_state
for agent in agents:
    account = world_state.create_account(agent.wallet_address)
    account.balance = 10000
    world_state.update_account(account)

# 执行投票
result = dao_executor.run(
    agents=agents,
    poll_role="DataDetective",
    poll_problem="根因分析",
    poll_content="服务 A 超时是否由数据库连接池耗尽导致？"
)

print(f"投票结果: {'通过' if result['passed'] else '未通过'}")
print(f"支持率: {result['statistics']['support_rate']:.1%}")
```

##### 6.3 创建并发送交易

```python
from core.client import ChainClient
from agents.base.profile import DataDetective

agent = DataDetective()
client = ChainClient(blockchain)

# 创建投票交易
tx = client.create_transaction(
    tx_type="vote",
    sender=agent.wallet_address,
    data={"proposal_id": "prop_001", "vote_option": "For"},
    private_key=agent.private_key
)

# 发送并出块
success = client.send_and_mine(tx)
print(f"交易上链: {'成功' if success else '失败'}")
```

### 成员 6: Agent 适配与 Prompt 工程

**核心职责**: Agent 身份与 Prompt 改造。

| 阶段            | 接口名                    | 输入             | 输出                                                     | 处理逻辑                                                                 |
| :-------------- | :------------------------ | :--------------- | :------------------------------------------------------- | :----------------------------------------------------------------------- |
| **身份管理**    | `AgentProfile` (数据结构) | 无               | `AgentProfile` (包含地址、私钥)                          | 生成/加载钱包私钥；为每个 Agent 实例分配身份。                           |
| **Prompt 改造** | `System Prompt`           | 原始运维任务描述 | 结构化的 Agent 输出 (包含 `action_type`, `stake_amount`) | 修改 System Prompt，注入“质押”、“经济激励”等约束；解析 LLM 输出为 JSON。 |

---

## 4. 前端交互组 (Frontend & API)

### 成员 7: 前端开发 (区块链浏览器)

**核心职责**: 区块链数据可视化。

| 阶段              | 接口名                                           | 输入                             | 输出                                        | 处理逻辑                                |
| :---------------- | :----------------------------------------------- | :------------------------------- | :------------------------------------------ | :-------------------------------------- |
| **后端 API 开发** | `GET /api/blocks`, `GET /api/transaction/{hash}` | `Blockchain` 对象 (来自成员 1/2) | JSON 数据                                   | 封装 FastAPI 接口，暴露区块和交易数据。 |
| **前端展示**      | `BlockExplorer` 组件                             | API 返回的 JSON 数据             | 渲染区块列表、交易详情页、Merkle 树验证视图 | 调用 API 获取数据并渲染。               |

### 成员 8: 前端开发 (运维控制台)

**核心职责**: 业务状态与经济看板。

| 阶段              | 接口名                                        | 输入                                               | 输出                                             | 处理逻辑                                            |
| :---------------- | :-------------------------------------------- | :------------------------------------------------- | :----------------------------------------------- | :-------------------------------------------------- |
| **后端 API 开发** | `GET /api/state/sop`, `GET /api/state/agents` | `OpsContract`, `TokenContract` 状态 (来自成员 3/4) | JSON 数据                                        | 封装 FastAPI 接口，暴露 SOP 状态和 Agent 资产信息。 |
| **前端展示**      | `SOPDashboard`, `EconomyMonitor` 组件         | API 返回的 JSON 数据                               | 渲染 SOP 流程图 (React Flow)、资产图表 (ECharts) | 调用 API 获取数据并渲染。                           |
